# -*- coding: utf-8 -*-
"""
Created on Sat Nov  9 17:11:39 2019

@author: khach
Пингвин Поло и отрезки
ограничение по времени на тест2 секунды
ограничение по памяти на тест256 мегабайт
вводстандартный ввод
выводстандартный вывод
Маленький пингвин Поло очень любит целочисленные отрезки, 
то есть пары целых чисел [l; r] (l ≤ r).

У него есть множество, состоящее из n целочисленных отрезков: [l1; r1], [l2; r2], ..., [ln; rn]. Известно, что никакие два отрезка этого множества не пересекаются. За один шаг Поло может расширить любой отрезок множества на 1 влево или на 1 вправо, то есть из отрезка [l; r] получить либо отрезок [l - 1; r], либо — [l; r + 1].

Величиной множества отрезков, состоящего из n отрезков [l1; r1], [l2; r2], ..., [ln; rn], назовем количество целых чисел x таких, что существует целое число j, для которого выполняется неравенство, lj ≤ x ≤ rj.

Найдите минимальное количество шагов, которое требуется, чтобы величина множества отрезков Поло делилась на k.

Входные данные
В первой строке заданы два целых числа n и k (1 ≤ n, k ≤ 105). В каждой из следующих n строк задан отрезок в виде пары целых чисел li и ri ( - 105 ≤ li ≤ ri ≤ 105), записанных через пробел.

Гарантируется, что никакие два отрезка не пересекаются. Другими словами, для любых двух целых чисел i, j (1 ≤ i < j ≤ n) выполняется неравенство, min(ri, rj) < max(li, lj).

Выходные данные
В единственной строке выведите целое число — ответ на задачу.
"""

n, k = map(int, input().split())
for i in range(n):
    l, r = map(int, input().split())
    
    j = 0
    while l % k == 0:
        if l % k == 0:
            continue
        else:
            l -= 1
    
    jj = 0
    while r % k == 0:
        if r % k == 0:
            continue
        else:
            jj += 1
print(min(j, jj))


